From 61359cfd8ec365e097a4cb01754e03c7a6bc910e Mon Sep 17 00:00:00 2001
From: novatekmsp <novatekmsp@gmail.com>
Date: Wed, 28 Jan 2026 17:11:12 +0800
Subject: [PATCH] nvt-ts: add Novatek touchscreen plugin

---
 .github/CODEOWNERS                |    1 +
 plugins/meson.build               |    1 +
 plugins/nvt-ts/README.md          |   46 +
 plugins/nvt-ts/fu-nvt-ts-plugin.c | 1687 +++++++++++++++++++++++++++++
 plugins/nvt-ts/fu-nvt-ts-plugin.h |  367 +++++++
 plugins/nvt-ts/meson.build        |   15 +
 plugins/nvt-ts/nvt-ts.quirk       |    3 +
 7 files changed, 2120 insertions(+)
 create mode 100644 plugins/nvt-ts/README.md
 create mode 100644 plugins/nvt-ts/fu-nvt-ts-plugin.c
 create mode 100644 plugins/nvt-ts/fu-nvt-ts-plugin.h
 create mode 100644 plugins/nvt-ts/meson.build
 create mode 100644 plugins/nvt-ts/nvt-ts.quirk

diff --git a/.github/CODEOWNERS b/.github/CODEOWNERS
index d90396eb1..33569b7e7 100644
--- a/.github/CODEOWNERS
+++ b/.github/CODEOWNERS
@@ -80,3 +80,4 @@ plugins/vli/ @memily
 plugins/wacom-raw/ @flying-elephant
 plugins/wacom-usb/ @jigpu
 plugins/wistron-dock/ @a999153
+plugins/nvt-ts/ @novatekmsp
diff --git a/plugins/meson.build b/plugins/meson.build
index c65ee9015..bc586ed78 100644
--- a/plugins/meson.build
+++ b/plugins/meson.build
@@ -148,6 +148,7 @@ plugins = {
   'wch-ch341a': false,
   'wch-ch347': false,
   'wistron-dock': false,
+  'nvt-ts': false,
 }
 
 umockdev_tests = []
diff --git a/plugins/nvt-ts/README.md b/plugins/nvt-ts/README.md
new file mode 100644
index 000000000..3e04913a3
--- /dev/null
+++ b/plugins/nvt-ts/README.md
@@ -0,0 +1,46 @@
+---
+title: Plugin: Novatek Touchscreen
+---
+
+## Introduction
+
+This plugin allows updating Novatek touchscreen controllers. Devices are
+enumerated using HIDRAW.
+
+## Firmware Format
+
+The daemon will decompress the cabinet archive and extract the firmware blob.
+
+This plugin expects a raw binary payload with an end flag of `NVT` and a
+maximum size of 320 KB.
+
+This plugin supports the following protocol ID:
+
+* `tw.com.novatek.ts`
+
+## GUID Generation
+
+These devices use the standard DeviceInstanceId values, e.g.
+
+* `HIDRAW\VEN_0603`
+
+An additional instance ID is added which corresponds to the PID read from
+flash:
+
+* `NVT_TS\VID_0603\PJID_%04X`
+
+## Update Behavior
+
+The device is updated after switching into idle mode, where the
+touchscreen is nonfunctional. The firmware is written using GCM commands with
+erase, program, and verify, and the device is reset back to normal runtime
+mode on success.
+
+## Vendor ID Security
+
+The vendor ID is set from the HID vendor, e.g. `HIDRAW:0x0603`
+
+## External Interface Access
+
+This plugin requires ioctl access to `HIDIOCSFEATURE` and `HIDIOCGFEATURE` and
+read/write access to `/dev/hidraw`.
diff --git a/plugins/nvt-ts/fu-nvt-ts-plugin.c b/plugins/nvt-ts/fu-nvt-ts-plugin.c
new file mode 100644
index 000000000..f1c2fb4d7
--- /dev/null
+++ b/plugins/nvt-ts/fu-nvt-ts-plugin.c
@@ -0,0 +1,1687 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+#include "config.h"
+
+#include "fu-nvt-ts-plugin.h"
+
+#undef G_LOG_DOMAIN
+#define G_LOG_DOMAIN "FuPluginNvtTs"
+
+#define NVT_TS_PLUGIN_VERSION "1"
+#define NVT_DEBUG_DRY_RUN     0
+
+static struct nvt_ts_data ts_data;
+static struct nvt_ts_data *const ts = &ts_data;
+static struct fw_bin fwb;
+static FuDevice *nvt_dev;
+gboolean if_flash_unknown_skip_status_register_control = TRUE;
+
+static void
+nvt_fw_bin_clear(void)
+{
+	g_clear_pointer(&fwb.bin_data, g_free);
+	fwb.bin_size = 0;
+}
+
+static int32_t
+ctp_hid_read_dev(FuDevice *device, uint32_t addr, uint8_t *data, uint16_t len, GError **error)
+{
+	int32_t ret;
+	uint8_t buf_set[12];
+	g_autofree uint8_t *buf_get = NULL;
+
+	if (len == 0) {
+		NVT_ERR("len must be > 0");
+		return -EINVAL;
+	}
+
+	NVT_DBG("read addr=0x%08x len=%u", addr, len);
+
+	/* set feature */
+	memset(buf_set, 0, sizeof(buf_set));
+
+	buf_set[0] = NVT_TS_REPORT_ID;
+	buf_set[1] = 0x0B;
+	buf_set[2] = 0x00;
+
+	buf_set[3] = (uint8_t)((ts->mmap->hid_i2c_eng_addr >> 0) & 0xFF);
+	buf_set[4] = (uint8_t)((ts->mmap->hid_i2c_eng_addr >> 8) & 0xFF);
+	buf_set[5] = (uint8_t)((ts->mmap->hid_i2c_eng_addr >> 16) & 0xFF);
+
+	buf_set[6] = (uint8_t)((addr >> 0) & 0xFF);
+	buf_set[7] = (uint8_t)((addr >> 8) & 0xFF);
+	buf_set[8] = (uint8_t)((addr >> 16) & 0xFF);
+	buf_set[9] = 0x00;
+
+	buf_set[10] = (uint8_t)(((len + 3) >> 0) & 0xFF);
+	buf_set[11] = (uint8_t)(((len + 3) >> 8) & 0xFF);
+
+	ret = fu_hidraw_device_set_feature(FU_HIDRAW_DEVICE(device),
+					   buf_set,
+					   sizeof(buf_set),
+					   FU_IOCTL_FLAG_RETRY,
+					   error);
+	if (!ret) {
+		NVT_ERR("set feature failed");
+		return -EIO;
+	}
+
+	/* get feature */
+	buf_get = g_new0(uint8_t, len + 1);
+	buf_get[0] = NVT_TS_REPORT_ID;
+
+	ret = fu_hidraw_device_get_feature(FU_HIDRAW_DEVICE(device),
+					   buf_get,
+					   len + 1,
+					   FU_IOCTL_FLAG_RETRY,
+					   error);
+	if (!ret) {
+		NVT_ERR("get feature failed");
+		return -EIO;
+	}
+
+	memcpy(data, buf_get + 1, len);
+
+	return 0;
+}
+
+static int32_t
+ctp_hid_write_dev(FuDevice *device, uint32_t addr, uint8_t *data, uint16_t len, GError **error)
+{
+	int32_t ret;
+	uint16_t write_len, report_len;
+	g_autofree uint8_t *buf_set = NULL;
+
+	if (len == 0) {
+		NVT_ERR("len must be > 0");
+		return -EINVAL;
+	}
+
+	NVT_DBG("write addr=0x%08x len=%u, data:", addr, len);
+	NVT_DBG_HEX(data, len);
+
+	write_len = len + 5;
+
+	report_len = write_len + 1;
+
+	buf_set = g_new0(uint8_t, report_len);
+
+	buf_set[0] = NVT_TS_REPORT_ID; /* report ID */
+	buf_set[1] = (uint8_t)(write_len & 0xFF);
+	buf_set[2] = (uint8_t)((write_len >> 8) & 0xFF);
+
+	buf_set[3] = (uint8_t)((addr >> 0) & 0xFF);
+	buf_set[4] = (uint8_t)((addr >> 8) & 0xFF);
+	buf_set[5] = (uint8_t)((addr >> 16) & 0xFF);
+
+	memcpy(&buf_set[6], data, len);
+
+	ret = fu_hidraw_device_set_feature(FU_HIDRAW_DEVICE(device),
+					   buf_set,
+					   report_len,
+					   FU_IOCTL_FLAG_RETRY,
+					   error);
+	if (!ret) {
+		NVT_ERR("set feature failed");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int32_t
+ctp_hid_read(uint32_t addr, uint8_t *data, uint16_t len)
+{
+	return ctp_hid_read_dev(nvt_dev, addr, data, len, NULL);
+}
+
+static int32_t
+ctp_hid_write(uint32_t addr, uint8_t *data, uint16_t len)
+{
+	return ctp_hid_write_dev(nvt_dev, addr, data, len, NULL);
+}
+
+static int32_t
+nvt_write_reg_bits(nvt_ts_reg_t reg, uint8_t val)
+{
+	uint8_t mask = 0, shift = 0, temp = 0;
+	uint8_t buf[8] = {0};
+	uint32_t addr = 0;
+	int32_t ret = 0;
+
+	addr = reg.addr;
+	mask = reg.mask;
+	temp = reg.mask;
+	shift = 0;
+	while (1) {
+		if ((temp >> shift) & 0x01)
+			break;
+		if (shift == 8) {
+			NVT_ERR("mask all bits zero!\n");
+			break;
+		}
+		shift++;
+	}
+	ret = ctp_hid_read(addr, buf, 1);
+	if (ret < 0) {
+		NVT_ERR("ctp_hid_read failed!(%d)\n", ret);
+		return ret;
+	}
+	temp = buf[0] & (~mask);
+	temp |= ((val << shift) & mask);
+	buf[0] = temp;
+	ret = ctp_hid_write(addr, buf, 1);
+	if (ret < 0) {
+		NVT_ERR("ctp_hid_write failed!(%d)\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int32_t
+find_fw_bin_end_flag(const uint8_t *base, uint32_t size, uint32_t *flag_offset, uint32_t *delta_out)
+{
+	const uint16_t step = 0x1000;
+	const char *expect = HID_FW_BIN_END_NAME_FULL;
+	uint32_t delta = 0;
+	char end_char[BIN_END_FLAG_LEN_MAX] = {0};
+
+	if (base == NULL || size < BIN_END_FLAG_LEN_MAX)
+		return -EFAULT;
+
+	for (delta = 0; size >= BIN_END_FLAG_LEN_MAX + delta; delta += step) {
+		uint32_t offset = size - delta - BIN_END_FLAG_LEN_MAX;
+
+		memcpy(end_char, base + offset, BIN_END_FLAG_LEN_MAX);
+		/* we now check "NVT" only */
+		if (memcmp(end_char + 1, expect, BIN_END_FLAG_LEN_FULL) == 0) {
+			if (flag_offset != NULL)
+				*flag_offset = offset;
+			if (delta_out != NULL)
+				*delta_out = delta;
+			return 0;
+		}
+
+		if (size < BIN_END_FLAG_LEN_MAX + delta + step)
+			break;
+	}
+
+	return -EFAULT;
+}
+
+static int32_t
+nvt_gcm_xfer(gcm_xfer_t *xfer)
+{
+	g_autofree uint8_t *buf = NULL;
+	uint32_t flash_cmd_addr = 0, flash_cmd_issue_addr = 0;
+	uint32_t rw_flash_data_addr = 0, tmp_addr = 0;
+	int32_t ret = 0, tmp_len = 0, i = 0, transfer_len = 0;
+	int32_t total_buf_size = 0, wait_cmd_issue_cnt = 0, write_len = 0;
+
+	wait_cmd_issue_cnt = 0;
+	flash_cmd_addr = ts->mmap->flash_cmd_addr;
+	flash_cmd_issue_addr = ts->mmap->flash_cmd_issue_addr;
+	rw_flash_data_addr = ts->mmap->rw_flash_data_addr;
+
+	transfer_len = NVT_TRANSFER_LEN;
+
+	total_buf_size = 64 + xfer->tx_len + xfer->rx_len;
+	buf = g_malloc0(total_buf_size);
+	if (buf == NULL) {
+		NVT_ERR("No memory for %d bytes", total_buf_size);
+		return -EAGAIN;
+	}
+
+	if ((xfer->tx_len > 0) && xfer->tx_buf != NULL) {
+		for (i = 0; i < xfer->tx_len; i += transfer_len) {
+			tmp_addr = rw_flash_data_addr + i;
+			tmp_len = MIN(xfer->tx_len - i, transfer_len);
+			memcpy(buf, xfer->tx_buf + i, tmp_len);
+			ret = ctp_hid_write(tmp_addr, buf, tmp_len);
+			if (ret < 0) {
+				NVT_ERR("Write tx data error");
+				return ret;
+			}
+		}
+	}
+
+	memset(buf, 0, total_buf_size);
+	buf[0] = xfer->flash_cmd;
+	if (xfer->flash_addr_len > 0) {
+		buf[1] = xfer->flash_addr & 0xFF;
+		buf[2] = (xfer->flash_addr >> 8) & 0xFF;
+		buf[3] = (xfer->flash_addr >> 16) & 0xFF;
+	} else {
+		buf[1] = 0x00;
+		buf[2] = 0x00;
+		buf[3] = 0x00;
+	}
+	write_len = xfer->flash_addr_len + xfer->pem_byte_len + xfer->dummy_byte_len + xfer->tx_len;
+	if (write_len > 0) {
+		buf[5] = write_len & 0xFF;
+		buf[6] = (write_len >> 8) & 0xFF;
+	} else {
+		buf[5] = 0x00;
+		buf[6] = 0x00;
+	}
+	if (xfer->rx_len > 0) {
+		buf[7] = xfer->rx_len & 0xFF;
+		buf[8] = (xfer->rx_len >> 8) & 0xFF;
+	} else {
+		buf[7] = 0x00;
+		buf[8] = 0x00;
+	}
+	buf[9] = xfer->flash_checksum & 0xFF;
+	buf[10] = (xfer->flash_checksum >> 8) & 0xFF;
+	buf[11] = 0xC2;
+	ret = ctp_hid_write(flash_cmd_addr, buf, 12);
+	if (ret < 0) {
+		NVT_ERR("Write enter GCM error");
+		return ret;
+	}
+
+	wait_cmd_issue_cnt = 0;
+	while (1) {
+		/* check flash cmd issue complete */
+		ret = ctp_hid_read(flash_cmd_issue_addr, buf, 1);
+		if (ret < 0) {
+			NVT_ERR("Read flash_cmd_issue_addr status error");
+			return ret;
+		}
+		if (buf[0] == 0x00) {
+			break;
+		}
+		wait_cmd_issue_cnt++;
+		if (wait_cmd_issue_cnt > 2000) {
+			NVT_ERR("write GCM cmd 0x%02X failed", xfer->flash_cmd);
+			return -EAGAIN;
+		}
+		msleep(1);
+	}
+
+	if ((xfer->rx_len > 0) && xfer->rx_buf != NULL) {
+		memset(buf, 0, xfer->rx_len);
+		for (i = 0; i < xfer->rx_len; i += transfer_len) {
+			tmp_addr = rw_flash_data_addr + i;
+			tmp_len = MIN(xfer->rx_len - i, transfer_len);
+			ret = ctp_hid_read(tmp_addr, buf, tmp_len);
+			if (ret < 0) {
+				NVT_ERR("Read rx data fail error");
+				return ret;
+			}
+			memcpy(xfer->rx_buf + i, buf, tmp_len);
+		}
+	}
+
+	return 0;
+}
+
+static int32_t
+write_enable_gcm(void)
+{
+	gcm_xfer_t xfer = {0};
+	int32_t ret = 0;
+
+	memset(&xfer, 0, sizeof(gcm_xfer_t));
+	xfer.flash_cmd = 0x06;
+	ret = nvt_gcm_xfer(&xfer);
+	if (ret) {
+		NVT_ERR("Write Enable failed, ret = %d", ret);
+		ret = -EAGAIN;
+	} else {
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static int32_t
+write_status_gcm(uint8_t status)
+{
+	uint8_t sr1 = 0;
+	int32_t ret = 0;
+	flash_wrsr_method_t wrsr_method = 0;
+	gcm_xfer_t xfer = {0};
+
+	memset(&xfer, 0, sizeof(gcm_xfer_t));
+	if (if_flash_unknown_skip_status_register_control &&
+	    ts->match_finfo->mid == FLASH_MFR_UNKNOWN) {
+		NVT_LOG("unknown flash for flash table skip status register control rdsr");
+		xfer.flash_cmd = 0x01;
+		xfer.flash_addr = status << 16;
+		xfer.flash_addr_len = 1;
+	} else {
+		wrsr_method = ts->match_finfo->wrsr_method;
+		if (wrsr_method == WRSR_01H1BYTE) {
+			xfer.flash_cmd = 0x01;
+			xfer.flash_addr = status << 16;
+			xfer.flash_addr_len = 1;
+		} else if (wrsr_method == WRSR_01H2BYTE) {
+			xfer.flash_cmd = ts->match_finfo->rdsr1_cmd;
+			xfer.rx_len = 1;
+			xfer.rx_buf = &sr1;
+			ret = nvt_gcm_xfer(&xfer);
+			if (ret) {
+				NVT_ERR("Read Status Register-1 fail!!(%d)", ret);
+				return -EINVAL;
+			} else {
+				NVT_DBG("Read Status Register-1 OK. sr1=0x%02X", sr1);
+			}
+
+			memset(&xfer, 0, sizeof(gcm_xfer_t));
+			xfer.flash_cmd = 0x01;
+			xfer.flash_addr = (status << 16) | (sr1 << 8);
+			xfer.flash_addr_len = 2;
+		} else {
+			NVT_ERR("Unknown or not support write status register method(%u)!",
+				wrsr_method);
+			return -EINVAL;
+		}
+	}
+	ret = nvt_gcm_xfer(&xfer);
+	if (ret) {
+		NVT_ERR("Write Status GCM fail, ret = %d", ret);
+		ret = -EAGAIN;
+	} else {
+		ret = 0;
+	}
+	return ret;
+}
+
+static int32_t
+read_status_gcm(uint8_t *status)
+{
+	gcm_xfer_t xfer = {0};
+	int32_t ret = 0;
+
+	memset(&xfer, 0, sizeof(gcm_xfer_t));
+	xfer.flash_cmd = 0x05;
+	xfer.rx_len = 1;
+	xfer.rx_buf = status;
+	ret = nvt_gcm_xfer(&xfer);
+	if (ret) {
+		NVT_ERR("Read Status GCM fail, ret = %d", ret);
+		ret = -EAGAIN;
+	} else {
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static int32_t
+sector_erase_gcm(uint32_t flash_addr)
+{
+	gcm_xfer_t xfer = {0};
+	int32_t ret = 0;
+
+	memset(&xfer, 0, sizeof(gcm_xfer_t));
+	xfer.flash_cmd = 0x20;
+	xfer.flash_addr = flash_addr;
+	xfer.flash_addr_len = 3;
+	ret = nvt_gcm_xfer(&xfer);
+	if (ret) {
+		NVT_ERR("Sector Erase GCM fail, ret = %d", ret);
+		ret = -EAGAIN;
+	} else {
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static int32_t
+page_program_gcm(uint32_t flash_addr, uint16_t data_len, uint8_t *data)
+{
+	gcm_xfer_t xfer = {0};
+	uint16_t checksum = 0;
+	int32_t ret = 0;
+	int32_t i = 0;
+
+	/* calculate checksum */
+	checksum = (flash_addr & 0xFF);
+	checksum += ((flash_addr >> 8) & 0xFF);
+	checksum += ((flash_addr >> 16) & 0xFF);
+	checksum += ((data_len + 3) & 0xFF);
+	checksum += (((data_len + 3) >> 8) & 0xFF);
+	for (i = 0; i < data_len; i++) {
+		checksum += data[i];
+	}
+	checksum = ~checksum + 1;
+
+	/* prepare gcm command transfer */
+	memset(&xfer, 0, sizeof(gcm_xfer_t));
+	xfer.flash_cmd = ts->flash_prog_data_cmd;
+	xfer.flash_addr = flash_addr;
+	xfer.flash_addr_len = 3;
+	xfer.tx_buf = data;
+	xfer.tx_len = data_len;
+	xfer.flash_checksum = checksum & 0xFFFF;
+	ret = nvt_gcm_xfer(&xfer);
+	if (ret) {
+		NVT_ERR("Page Program GCM fail, ret = %d", ret);
+		ret = -EAGAIN;
+	} else {
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static int32_t
+get_checksum_gcm(uint32_t flash_addr, uint32_t data_len, uint16_t *checksum)
+{
+	gcm_xfer_t xfer = {0};
+	uint8_t buf[2] = {0};
+	int32_t ret = 0;
+
+	memset(&xfer, 0, sizeof(gcm_xfer_t));
+	xfer.flash_cmd = ts->flash_read_data_cmd;
+	xfer.flash_addr = flash_addr;
+	xfer.flash_addr_len = 3;
+	xfer.pem_byte_len = ts->flash_read_pem_byte_len;
+	xfer.dummy_byte_len = ts->flash_read_dummy_byte_len;
+	xfer.rx_len = data_len;
+	ret = nvt_gcm_xfer(&xfer);
+	if (ret) {
+		NVT_ERR("Get Checksum GCM fail, ret = %d", ret);
+		return -EAGAIN;
+	}
+
+	buf[0] = 0x00;
+	buf[1] = 0x00;
+	ret = ctp_hid_read(ts->mmap->read_flash_checksum_addr, buf, 2);
+	if (ret < 0) {
+		NVT_ERR("Get checksum error, ret = %d", ret);
+		return -EAGAIN;
+	}
+	*checksum = (buf[1] << 8) | buf[0];
+
+	return 0;
+}
+
+static int32_t
+switch_gcm(uint8_t enable)
+{
+	uint8_t buf[3] = {0}, retry = 0, retry_max = 0;
+	int32_t ret = 0;
+
+	retry_max = 3;
+
+	while (1) {
+		if (enable) {
+			buf[0] = 0x55;
+			buf[1] = 0xFF;
+			buf[2] = 0xAA;
+		} else {
+			buf[0] = 0xAA;
+			buf[1] = 0x55;
+			buf[2] = 0xFF;
+		}
+		ret = ctp_hid_write(ts->mmap->gcm_code_addr, buf, 3);
+		if (ret < 0)
+			return ret;
+		ret = ctp_hid_read(ts->mmap->gcm_flag_addr, buf, 1);
+		if (ret < 0)
+			return ret;
+		if (enable) {
+			if ((buf[0] & 0x01) == 0x01) {
+				ret = 0;
+				break;
+			}
+		} else {
+			if ((buf[0] & 0x01) == 0x00) {
+				ret = 0;
+				break;
+			}
+		}
+		NVT_LOG("Result mismatch, retry");
+		retry++;
+		if (retry == retry_max) {
+			if (enable)
+				NVT_ERR("Enable gcm failed");
+			else
+				NVT_ERR("Disable gcm failed");
+			ret = -EAGAIN;
+			break;
+		}
+	}
+
+	if (!ret) {
+		if (enable)
+			NVT_LOG("Enable gcm OK");
+		else
+			NVT_LOG("Disable gcm OK");
+	}
+
+	return ret;
+}
+
+static int32_t
+resume_pd_gcm(void)
+{
+	int32_t ret = 0;
+	gcm_xfer_t xfer = {0};
+
+	memset(&xfer, 0, sizeof(gcm_xfer_t));
+	xfer.flash_cmd = 0xAB;
+	ret = nvt_gcm_xfer(&xfer);
+	if (ret) {
+		NVT_ERR("Resume PD failed, ret = %d", ret);
+		ret = -EAGAIN;
+	} else {
+		NVT_DBG("Resume PD OK");
+		ret = 0;
+	}
+
+	return ret;
+}
+
+static int32_t
+erase_flash_gcm(void)
+{
+	flash_mfr_t mid = 0;
+	uint8_t status = 0;
+	int32_t ret = 0;
+	int32_t count = 0;
+	int32_t i = 0;
+	int32_t flash_address = 0;
+	int32_t retry = 0;
+	int32_t erase_length = 0;
+	int32_t start_sector = 0;
+	const flash_qeb_info_t *qeb_info_p = NULL;
+
+	if (fwb.flash_start_addr % FLASH_SECTOR_SIZE) {
+		NVT_ERR("flash_start_addr should be n*%d", FLASH_SECTOR_SIZE);
+		return -EINVAL;
+	}
+
+	start_sector = fwb.flash_start_addr / FLASH_SECTOR_SIZE;
+	erase_length = fwb.bin_size - fwb.flash_start_addr;
+	if (erase_length < 0) {
+		NVT_ERR("Wrong erase_length = %d", erase_length);
+		return -EINVAL;
+	}
+
+	/* write enable */
+	ret = write_enable_gcm();
+	if (ret < 0) {
+		NVT_ERR("Write Enable error, ret = %d", ret);
+		return -EAGAIN;
+	}
+
+	if (if_flash_unknown_skip_status_register_control &&
+	    ts->match_finfo->mid == FLASH_MFR_UNKNOWN) {
+		NVT_LOG("unknown flash for flash table skip status register control qeb");
+		ret = write_status_gcm(status);
+		if (ret < 0) {
+			NVT_ERR("Write Status Register error, ret = %d", ret);
+			return -EAGAIN;
+		}
+	} else {
+		mid = ts->match_finfo->mid;
+		qeb_info_p = &ts->match_finfo->qeb_info;
+		if ((mid != FLASH_MFR_UNKNOWN) && (qeb_info_p->qeb_pos != QEB_POS_UNKNOWN)) {
+			/* check if QE bit is in status register byte 1, if yes set it back to 1 */
+			if (qeb_info_p->qeb_pos == QEB_POS_SR_1B) {
+				status = (0x01 << qeb_info_p->qeb_order);
+			} else {
+				status = 0x00;
+			}
+			/* write status register */
+			ret = write_status_gcm(status);
+			if (ret < 0) {
+				NVT_ERR("Write Status Register error, ret = %d", ret);
+				return -EAGAIN;
+			}
+			NVT_DBG("Write Status Register byte 0x%02X OK", status);
+			msleep(1);
+		}
+	}
+
+	/* read status */
+	retry = 0;
+	while (1) {
+		retry++;
+		msleep(5);
+		if (retry > 100) {
+			NVT_ERR("Read Status failed, status = 0x%02X", status);
+			return -EAGAIN;
+		}
+		ret = read_status_gcm(&status);
+		if (ret < 0) {
+			NVT_ERR("Read Status Register error, ret = %d", ret);
+			continue;
+		}
+		if ((status & 0x03) == 0x00) {
+			NVT_DBG("Read Status Register byte 0x%02X OK", status);
+			break;
+		}
+	}
+
+	if (erase_length % FLASH_SECTOR_SIZE)
+		count = erase_length / FLASH_SECTOR_SIZE + start_sector + 1;
+	else
+		count = erase_length / FLASH_SECTOR_SIZE + start_sector;
+
+	for (i = start_sector; i < count; i++) {
+		/* write enable */
+		ret = write_enable_gcm();
+		if (ret < 0) {
+			NVT_ERR("Write enable error, ret = %d, page at = %d",
+				ret,
+				i * FLASH_SECTOR_SIZE);
+			return -EAGAIN;
+		}
+
+		flash_address = i * FLASH_SECTOR_SIZE;
+
+		/* sector erase */
+		ret = sector_erase_gcm(flash_address);
+		if (ret < 0) {
+			NVT_ERR("Sector erase error, ret = %d, page at = %d",
+				ret,
+				i * FLASH_SECTOR_SIZE);
+			return -EAGAIN;
+		}
+		msleep(25);
+
+		retry = 0;
+		while (1) {
+			retry++;
+			if (retry > 100) {
+				NVT_ERR("Wait sector erase timeout");
+				return -EAGAIN;
+			}
+			ret = read_status_gcm(&status);
+			if (ret < 0) {
+				NVT_ERR("Read status register error, ret = %d", ret);
+				continue;
+			}
+			if ((status & 0x03) == 0x00) {
+				ret = 0;
+				break;
+			}
+			msleep(5);
+		}
+	}
+
+	NVT_LOG("Erase OK");
+
+	return 0;
+}
+
+static int32_t
+nvt_set_prog_flash_method(void)
+{
+	flash_prog_method_t prog_method = 0;
+	uint8_t pp4io_en = 0;
+	uint8_t q_wr_cmd = 0;
+	uint8_t bld_rd_addr_sel = 0;
+	uint8_t buf[4] = {0};
+	int32_t ret = 0;
+
+	prog_method = ts->match_finfo->prog_method;
+	switch (prog_method) {
+	case SPP_0x02:
+		ts->flash_prog_data_cmd = 0x02;
+		pp4io_en = 0;
+		q_wr_cmd = 0x00; /* not 0x02, must 0x00! */
+		break;
+	case QPP_0x32:
+		ts->flash_prog_data_cmd = 0x32;
+		pp4io_en = 1;
+		q_wr_cmd = 0x32;
+		bld_rd_addr_sel = 0;
+		break;
+	case QPP_0x38:
+		ts->flash_prog_data_cmd = 0x38;
+		pp4io_en = 1;
+		q_wr_cmd = 0x38;
+		bld_rd_addr_sel = 1;
+		break;
+	default:
+		NVT_ERR("flash program method %u not support!", prog_method);
+		return -EINVAL;
+	}
+	NVT_DBG("prog_method=%u, ts->flash_prog_data_cmd=0x%02X",
+		prog_method,
+		ts->flash_prog_data_cmd);
+	NVT_DBG("pp4io_en=%d, q_wr_cmd=0x%02X, bld_rd_addr_sel=0x%02X",
+		pp4io_en,
+		q_wr_cmd,
+		bld_rd_addr_sel);
+
+	if (ts->mmap->pp4io_en_reg.addr) {
+		ret = nvt_write_reg_bits(ts->mmap->pp4io_en_reg, pp4io_en);
+		if (ret < 0) {
+			NVT_ERR("set pp4io_en_reg failed, ret = %d", ret);
+			return ret;
+		} else {
+			NVT_DBG("set pp4io_en_reg=%d done", pp4io_en);
+		}
+	}
+	if (ts->mmap->q_wr_cmd_addr) {
+		buf[0] = q_wr_cmd;
+		ret = ctp_hid_write(ts->mmap->q_wr_cmd_addr, buf, 1);
+		if (ret < 0) {
+			NVT_ERR("set q_wr_cmd_addr failed, ret = %d", ret);
+			return ret;
+		} else {
+			NVT_DBG("set Q_WR_CMD_ADDR=0x%02X done", q_wr_cmd);
+		}
+	}
+	if (pp4io_en) {
+		if (ts->mmap->bld_rd_addr_sel_reg.addr) {
+			ret = nvt_write_reg_bits(ts->mmap->bld_rd_addr_sel_reg, bld_rd_addr_sel);
+			if (ret < 0) {
+				NVT_ERR("set bld_rd_addr_sel_reg failed, ret = %d", ret);
+				return ret;
+			} else {
+				NVT_DBG("set bld_rd_addr_sel_reg=%d done", bld_rd_addr_sel);
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int32_t
+write_flash_gcm(void)
+{
+	uint8_t page_program_retry = 0;
+	uint8_t buf[1] = {0};
+	uint32_t flash_address = 0;
+	uint32_t flash_cksum_status_addr = ts->mmap->flash_cksum_status_addr;
+	uint32_t step = 10, pre = 0, show = 0;
+	int32_t ret = 0;
+	int32_t i = 0;
+	int32_t count = 0;
+	int32_t retry = 0;
+	uint8_t status = 0;
+
+	nvt_set_prog_flash_method();
+
+	count = (fwb.bin_size - fwb.flash_start_addr) / FLASH_PAGE_SIZE;
+	if ((fwb.bin_size - fwb.flash_start_addr) % FLASH_PAGE_SIZE)
+		count++;
+
+	for (i = 0; i < count; i++) {
+		flash_address = i * FLASH_PAGE_SIZE + fwb.flash_start_addr;
+		page_program_retry = 0;
+
+	page_program_start:
+		/* write enable */
+		ret = write_enable_gcm();
+		if (ret < 0) {
+			NVT_ERR("Write Enable error, ret = %d", ret);
+			return -EAGAIN;
+		}
+		/* write page: FLASH_PAGE_SIZE bytes */
+		/* page program */
+		ret = page_program_gcm(flash_address,
+				       MIN(fwb.bin_size - flash_address, FLASH_PAGE_SIZE),
+				       &fwb.bin_data[flash_address]);
+		if (ret < 0) {
+			NVT_ERR("Page Program error, ret = %d, i= %d", ret, i);
+			return -EAGAIN;
+		}
+
+		/* check flash checksum status */
+		retry = 0;
+		while (1) {
+			buf[0] = 0x00;
+			ret = ctp_hid_read(flash_cksum_status_addr, buf, 1);
+			if (buf[0] == 0xAA) { /* checksum pass */
+				ret = 0;
+				break;
+			} else if (buf[0] == 0xEA) { /* checksum error */
+				if (page_program_retry < 1) {
+					page_program_retry++;
+					goto page_program_start;
+				} else {
+					NVT_ERR("Check Flash Checksum Status error");
+					return -EAGAIN;
+				}
+			}
+			retry++;
+			if (retry > 20) {
+				NVT_ERR("Check flash checksum fail, buf[0] = 0x%02X", buf[0]);
+				return -EAGAIN;
+			}
+			msleep(1);
+		}
+
+		/* read status */
+		retry = 0;
+		while (1) {
+			retry++;
+			if (retry > 200) {
+				NVT_ERR("Wait Page Program timeout");
+				return -EAGAIN;
+			}
+			/* read status */
+			ret = read_status_gcm(&status);
+			if (ret < 0) {
+				NVT_ERR("Read Status Register error, ret = %d", ret);
+				continue;
+			}
+			if ((status & 0x03) == 0x00) {
+				ret = 0;
+				break;
+			}
+			msleep(1);
+		}
+
+		/* show progress */
+		show = ((i * 100) / step / count);
+		if (pre != show) {
+			NVT_LOG("Programming...%2u%%", show * step);
+			pre = show;
+		}
+	}
+	NVT_LOG("Programming...%d%%", 100);
+	NVT_LOG("Program OK");
+
+	return 0;
+}
+
+static int32_t
+nvt_set_read_flash_method(void)
+{
+	uint8_t bld_rd_io_sel = 0;
+	uint8_t bld_rd_addr_sel = 0;
+	int32_t ret = 0;
+	flash_read_method_t rd_method = 0;
+
+	bld_rd_io_sel = 0;
+	bld_rd_addr_sel = 0;
+	ret = 0;
+	rd_method = ts->match_finfo->rd_method;
+	switch (rd_method) {
+	case SISO_0x03:
+		ts->flash_read_data_cmd = 0x03;
+		ts->flash_read_pem_byte_len = 0;
+		ts->flash_read_dummy_byte_len = 0;
+		bld_rd_io_sel = 0;
+		bld_rd_addr_sel = 0;
+		break;
+	case SISO_0x0B:
+		ts->flash_read_data_cmd = 0x0B;
+		ts->flash_read_pem_byte_len = 0;
+		ts->flash_read_dummy_byte_len = 1;
+		bld_rd_io_sel = 0;
+		bld_rd_addr_sel = 0;
+		break;
+	case SIQO_0x6B:
+		ts->flash_read_data_cmd = 0x6B;
+		ts->flash_read_pem_byte_len = 0;
+		ts->flash_read_dummy_byte_len = 4;
+		bld_rd_io_sel = 2;
+		bld_rd_addr_sel = 0;
+		break;
+	case QIQO_0xEB:
+		ts->flash_read_data_cmd = 0xEB;
+		ts->flash_read_pem_byte_len = 1;
+		ts->flash_read_dummy_byte_len = 2;
+		bld_rd_io_sel = 2;
+		bld_rd_addr_sel = 1;
+		break;
+	default:
+		NVT_ERR("flash read method %u not support!", rd_method);
+		return -EINVAL;
+	}
+	NVT_DBG("rd_method = %u, ts->flash_read_data_cmd = 0x%02X",
+		rd_method,
+		ts->flash_read_data_cmd);
+	NVT_DBG("ts->flash_read_pem_byte_len = %d, ts->flash_read_dummy_byte_len = %d",
+		ts->flash_read_pem_byte_len,
+		ts->flash_read_dummy_byte_len);
+	NVT_DBG("bld_rd_io_sel = %d, bld_rd_addr_sel = %d", bld_rd_io_sel, bld_rd_addr_sel);
+
+	if (ts->mmap->bld_rd_io_sel_reg.addr) {
+		ret = nvt_write_reg_bits(ts->mmap->bld_rd_io_sel_reg, bld_rd_io_sel);
+		if (ret < 0) {
+			NVT_ERR("set bld_rd_io_sel_reg failed, ret = %d", ret);
+			return ret;
+		} else {
+			NVT_DBG("set bld_rd_io_sel_reg=%d done", bld_rd_io_sel);
+		}
+	}
+	if (ts->mmap->bld_rd_addr_sel_reg.addr) {
+		ret = nvt_write_reg_bits(ts->mmap->bld_rd_addr_sel_reg, bld_rd_addr_sel);
+		if (ret < 0) {
+			NVT_ERR("set bld_rd_addr_sel_reg failed, ret = %d", ret);
+			return ret;
+		} else {
+			NVT_DBG("set bld_rd_addr_sel_reg=%d done", bld_rd_addr_sel);
+		}
+	}
+
+	return 0;
+}
+
+static int32_t
+verify_flash_gcm(void)
+{
+	uint16_t write_checksum = 0;
+	uint16_t read_checksum = 0;
+	uint32_t flash_addr = 0;
+	uint32_t data_len = 0;
+	int32_t ret = 0;
+	uint32_t total_sector_need_check = 0;
+	uint32_t i = 0;
+	uint32_t j = 0;
+
+	nvt_set_read_flash_method();
+
+	total_sector_need_check = (fwb.bin_size - fwb.flash_start_addr) / SIZE_4KB;
+	for (i = 0; i < total_sector_need_check; i++) {
+		flash_addr = i * SIZE_4KB + fwb.flash_start_addr;
+		data_len = SIZE_4KB;
+		/* calculate write_checksum of each 4KB block */
+		write_checksum = (flash_addr & 0xFF);
+		write_checksum += ((flash_addr >> 8) & 0xFF);
+		write_checksum += ((flash_addr >> 16) & 0xFF);
+		write_checksum += ((data_len)&0xFF);
+		write_checksum += (((data_len) >> 8) & 0xFF);
+		for (j = 0; j < data_len; j++) {
+			write_checksum += fwb.bin_data[flash_addr + j];
+		}
+		write_checksum = ~write_checksum + 1;
+
+		ret = get_checksum_gcm(flash_addr, data_len, &read_checksum);
+		if (ret < 0) {
+			NVT_ERR("Get Checksum failed, ret = %d, i = %u", ret, i);
+			return -EAGAIN;
+		}
+		if (write_checksum != read_checksum) {
+			NVT_ERR("Verify Failed, i = %u, write_checksum = 0x%04X, "
+				"read_checksum = 0x%04X",
+				i,
+				write_checksum,
+				read_checksum);
+			return -EAGAIN;
+		}
+	}
+
+	NVT_LOG("Verify OK");
+
+	return 0;
+}
+
+static int32_t
+nvt_find_match_flash_info(void)
+{
+	uint32_t i = 0, total_info_items = 0;
+	const struct flash_info *finfo = NULL;
+
+	total_info_items = sizeof(flash_info_table) / sizeof(flash_info_table[0]);
+	for (i = 0; i < total_info_items; i++) {
+		if (flash_info_table[i].mid == ts->flash_mid) {
+			/* mid of this flash info item match current flash's mid */
+			if (flash_info_table[i].did == ts->flash_did) {
+				/* specific mid and did of this flash info item
+				 * match current flash's mid and did */
+				break;
+			} else if (flash_info_table[i].did == FLASH_DID_ALL) {
+				/* mid of this flash info item match current
+				 * flash's mid, and all did have same flash info */
+				break;
+			}
+		} else if (flash_info_table[i].mid == FLASH_MFR_UNKNOWN) {
+			/* reach the last item of flash_info_table, no flash info item matched */
+			break;
+		} else {
+			/* mid of this flash info item not math current flash's mid */
+			continue;
+		}
+	}
+	ts->match_finfo = &flash_info_table[i];
+	finfo = ts->match_finfo;
+	NVT_DBG("matched flash info item %u:", i);
+	NVT_DBG("mid = 0x%02X, did = 0x%04X, qeb_pos = %u",
+		finfo->mid,
+		finfo->did,
+		finfo->qeb_info.qeb_pos);
+	NVT_DBG("qeb_order = %u, rd_method = %u, prog_method = %u",
+		finfo->qeb_info.qeb_order,
+		finfo->rd_method,
+		finfo->prog_method);
+	NVT_DBG("wrsr_method = %u, rdsr1_cmd_ = 0x%02X", finfo->wrsr_method, finfo->rdsr1_cmd);
+
+	return 0;
+}
+
+static int32_t
+read_flash_mid_did_gcm(void)
+{
+	uint8_t buf[3];
+	int32_t ret = 0;
+	gcm_xfer_t xfer = {0};
+
+	memset(&xfer, 0, sizeof(gcm_xfer_t));
+	xfer.flash_cmd = 0x9F;
+	xfer.rx_buf = buf;
+	xfer.rx_len = 3;
+	ret = nvt_gcm_xfer(&xfer);
+	if (ret) {
+		NVT_ERR("Read Flash MID DID GCM fail, ret = %d", ret);
+		return -EAGAIN;
+	}
+
+	ts->flash_mid = buf[0];
+	ts->flash_did = (buf[1] << 8) | buf[2];
+	NVT_DBG("Flash MID = 0x%02X, DID = 0x%04X", ts->flash_mid, ts->flash_did);
+	nvt_find_match_flash_info();
+	NVT_DBG("Read MID DID OK");
+	return 0;
+}
+
+static int32_t
+check_end_flag(void)
+{
+	const uint32_t sz = fwb.bin_size;
+	const uint8_t *base = (const uint8_t *)fwb.bin_data;
+	char end_char[BIN_END_FLAG_LEN_MAX] = {0};
+	uint32_t new_sz = 0;
+	uint32_t flag_offset = 0;
+	uint32_t delta = 0;
+	int32_t ret = 0;
+
+	ret = find_fw_bin_end_flag(base, sz, &flag_offset, &delta);
+	if (ret) {
+		NVT_ERR("binary end flag not found at end or at (-0x1000) steps (expected [%s]), "
+			"abort.",
+			HID_FW_BIN_END_NAME_FULL);
+		return ret;
+	}
+
+	memcpy(end_char, base + flag_offset, BIN_END_FLAG_LEN_MAX);
+	NVT_LOG("Found HID FW bin flag [%.*s] at offset 0x%X (probe delta 0x%X).",
+		BIN_END_FLAG_LEN_FULL,
+		end_char + 1,
+		flag_offset + 1,
+		delta);
+	NVT_LOG("Raw end bytes = [%c%c%c%c]", end_char[0], end_char[1], end_char[2], end_char[3]);
+
+	new_sz = flag_offset + BIN_END_FLAG_LEN_MAX;
+	NVT_LOG("Update fw bin size from 0x%X to 0x%X", sz, new_sz);
+	fwb.bin_size = new_sz;
+	return 0;
+}
+
+static int32_t
+get_binary_and_flash_start_addr_from_blob(const guint8 *data, gsize size)
+{
+	int32_t ret = 0;
+
+	if (data == NULL || size == 0) {
+		NVT_ERR("invalid firmware blob (data=%p size=0x%zX)", data, size);
+		return -EINVAL;
+	}
+
+	nvt_fw_bin_clear();
+
+	if (size > MAX_BIN_SIZE) {
+		NVT_ERR("firmware blob too large (0x%zX > 0x%X)", size, (uint32_t)MAX_BIN_SIZE);
+		return -E2BIG;
+	}
+
+	fwb.bin_data = g_malloc(size);
+	if (fwb.bin_data == NULL) {
+		NVT_ERR("malloc for firmware blob failed (size=0x%zX)", size);
+		return -ENOMEM;
+	}
+	memcpy(fwb.bin_data, data, size);
+	fwb.bin_size = (uint32_t)size;
+
+	/* check and trim according to end-flag if needed */
+	ret = check_end_flag();
+	if (ret)
+		return ret;
+
+	if (ts->fmap->flash_normal_fw_start_addr == 0) {
+		NVT_ERR("normal FW flash should not start from 0");
+		return -EFAULT;
+	}
+
+	/* always use FLASH_NORMAL start (0x2000) */
+	fwb.flash_start_addr = ts->fmap->flash_normal_fw_start_addr;
+
+	NVT_LOG("Flashing starts from 0x%X", fwb.flash_start_addr);
+	NVT_LOG("Size of bin for update = 0x%05X", fwb.bin_size);
+	NVT_LOG("Get binary from blob OK");
+
+	return 0;
+}
+
+static int32_t
+update_firmware(const guint8 *data, gsize size)
+{
+	int32_t ret = 0;
+
+	NVT_LOG("Get binary and flash start address");
+	ret = get_binary_and_flash_start_addr_from_blob(data, size);
+	if (ret) {
+		nvt_fw_bin_clear();
+		return ret;
+	}
+
+	NVT_LOG("Enable gcm");
+	ret = switch_gcm(1);
+	if (ret) {
+		nvt_fw_bin_clear();
+		return ret;
+	}
+
+	NVT_LOG("Resume PD");
+	ret = resume_pd_gcm();
+	if (ret) {
+		nvt_fw_bin_clear();
+		return ret;
+	}
+
+	NVT_LOG("Read flash ID");
+	ret = read_flash_mid_did_gcm();
+	if (ret) {
+		nvt_fw_bin_clear();
+		return ret;
+	}
+
+	NVT_LOG("Erase");
+	ret = erase_flash_gcm();
+	if (ret) {
+		nvt_fw_bin_clear();
+		return ret;
+	}
+
+	NVT_LOG("Program");
+	ret = write_flash_gcm();
+	if (ret) {
+		nvt_fw_bin_clear();
+		return ret;
+	}
+
+	NVT_LOG("Verify");
+	ret = verify_flash_gcm();
+	if (ret) {
+		nvt_fw_bin_clear();
+		return ret;
+	}
+
+	nvt_fw_bin_clear();
+	return 0;
+}
+
+static void
+nvt_bootloader_reset(void)
+{
+	uint8_t buf[1] = {0};
+
+	buf[0] = 0x69;
+	ctp_hid_write(ts->mmap->swrst_sif_addr, buf, 1);
+	NVT_DBG("0x69 to 0x%06X", ts->mmap->swrst_sif_addr);
+	msleep(235);
+}
+
+static void
+nvt_sw_reset_and_idle(void)
+{
+	uint8_t buf[1] = {0};
+
+	buf[0] = 0xAA;
+	ctp_hid_write(ts->mmap->swrst_sif_addr, buf, 1);
+	NVT_DBG("0xAA to 0x%06X", ts->mmap->swrst_sif_addr);
+	msleep(50);
+}
+
+static void
+nvt_stop_crc_reboot(void)
+{
+	uint8_t buf[1] = {0};
+	uint8_t retry = 20;
+
+	NVT_DBG("%s (0xA5 to 0x%06X) %d times", __func__, ts->mmap->bld_spe_pups_addr, retry);
+	while (retry--) {
+		buf[0] = 0xA5;
+		ctp_hid_write(ts->mmap->bld_spe_pups_addr, buf, 1);
+	}
+	msleep(5);
+}
+
+static int32_t
+update_firmware_reset(const guint8 *data, gsize size)
+{
+	int32_t ret = 0;
+
+	nvt_bootloader_reset();
+	nvt_sw_reset_and_idle();
+	nvt_stop_crc_reboot();
+
+	ret = update_firmware(data, size);
+
+	nvt_bootloader_reset();
+
+	return ret;
+}
+
+struct _FuNvtTsPlugin {
+	FuPlugin parent_instance;
+};
+
+G_DEFINE_TYPE(FuNvtTsPlugin, fu_nvt_ts_plugin, FU_TYPE_PLUGIN)
+
+static void
+fu_nvt_ts_plugin_constructed(GObject *obj)
+{
+	FuPlugin *plugin;
+
+	G_OBJECT_CLASS(fu_nvt_ts_plugin_parent_class)->constructed(obj);
+
+	NVT_LOG("plugin constructed");
+
+	plugin = FU_PLUGIN(obj);
+
+	if (fu_plugin_get_name(plugin) == NULL)
+		fwupd_plugin_set_name(FWUPD_PLUGIN(plugin), "nvt_ts");
+
+	fu_plugin_add_device_udev_subsystem(plugin, "hidraw");
+
+	fu_plugin_add_device_gtype(plugin, FU_TYPE_NVT_TS_DEVICE);
+
+	/* fu_plugin_add_firmware_gtype(plugin, NULL, FU_TYPE_NVT_TS_FIRMWARE); */
+}
+
+static void
+fu_nvt_ts_plugin_class_init(FuNvtTsPluginClass *klass)
+{
+	GObjectClass *object_class;
+
+	NVT_LOG("plugin class init");
+
+	object_class = G_OBJECT_CLASS(klass);
+	object_class->constructed = fu_nvt_ts_plugin_constructed;
+}
+
+static void
+fu_nvt_ts_plugin_init(FuNvtTsPlugin *self)
+{
+	NVT_LOG("plugin init, plugin version %s", NVT_TS_PLUGIN_VERSION);
+}
+
+struct _FuNvtTsDevice {
+	FuHidrawDevice parent_instance;
+};
+
+G_DEFINE_TYPE(FuNvtTsDevice, fu_nvt_ts_device, FU_TYPE_HIDRAW_DEVICE)
+
+static gboolean
+fu_nvt_ts_device_probe(FuDevice *device, GError **error)
+{
+	const gchar *subsystem;
+
+	NVT_LOG("device probe");
+
+	subsystem = fu_udev_device_get_subsystem(FU_UDEV_DEVICE(device));
+	if (g_strcmp0(subsystem, "hidraw") != 0) {
+		NVT_ERR("subsystem is not hidraw");
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static void
+nvt_clear_fw_reset_state(void)
+{
+	uint8_t buf[1] = {0};
+
+	ctp_hid_write(ts->mmap->event_buf_reset_state_addr, buf, 1);
+	NVT_DBG("0x00 to 0x%06X", ts->mmap->event_buf_reset_state_addr);
+}
+
+static int32_t
+nvt_check_fw_reset_state(uint8_t state)
+{
+	uint8_t buf[1] = {0};
+	int32_t ret = 0, retry = 100;
+
+	NVT_LOG("checking reset state from address 0x%06X for state 0x%02X",
+		ts->mmap->event_buf_reset_state_addr,
+		state);
+
+	/* first clear */
+	nvt_clear_fw_reset_state();
+
+	while (--retry) {
+		msleep(10);
+		ctp_hid_read(ts->mmap->event_buf_reset_state_addr, buf, 1);
+
+		if ((buf[0] >= state) && (buf[0] <= RESET_STATE_MAX)) {
+			ret = 0;
+			break;
+		}
+	}
+
+	if (retry == 0) {
+		NVT_ERR("error, reset state buf[0] = 0x%02X", buf[0]);
+		ret = -EAGAIN;
+	} else {
+		NVT_LOG("reset state 0x%02X pass", state);
+	}
+
+	return ret;
+}
+
+static int32_t
+nvt_get_fw_ver(void)
+{
+	uint8_t buf[2] = {0};
+	int32_t ret = 0;
+	uint8_t retry = 10;
+
+	while (--retry) {
+		ctp_hid_read(ts->mmap->event_map_fwinfo_addr, buf, 2);
+		if ((uint8_t)(buf[0] + buf[1]) == 0xFF)
+			break;
+	}
+
+	if (!retry) {
+		NVT_ERR("FW info is broken, fw_ver=0x%02X, ~fw_ver=0x%02X", buf[0], buf[1]);
+		return -EAGAIN;
+	}
+
+	ts->fw_ver = buf[0];
+	NVT_LOG("fw_ver = 0x%02X", ts->fw_ver);
+	return ret;
+}
+
+static int32_t
+nvt_read_flash_data_gcm(uint32_t flash_addr, uint16_t len, uint8_t *out)
+{
+	gcm_xfer_t xfer = {0};
+	uint8_t buf[2] = {0};
+	uint16_t rd_checksum = 0;
+	uint16_t calc = 0;
+	uint16_t i = 0;
+	uint8_t retry = 10;
+	int32_t ret = 0;
+
+	if (out == NULL || len == 0)
+		return -EINVAL;
+	/* keep this simple; expand later if you want >256 */
+	if (len > 256)
+		return -EINVAL;
+
+	while (retry--) {
+		calc = 0;
+		calc += (flash_addr >> 16) & 0xFF;
+		calc += (flash_addr >> 8) & 0xFF;
+		calc += (flash_addr >> 0) & 0xFF;
+		calc += (len >> 8) & 0xFF;
+		calc += (len >> 0) & 0xFF;
+
+		memset(&xfer, 0, sizeof(xfer));
+		xfer.flash_cmd = ts->flash_read_data_cmd;
+		xfer.flash_addr = flash_addr;
+		xfer.flash_addr_len = 3;
+		xfer.pem_byte_len = ts->flash_read_pem_byte_len;
+		xfer.dummy_byte_len = ts->flash_read_dummy_byte_len;
+		xfer.rx_buf = out;
+		xfer.rx_len = len;
+
+		ret = nvt_gcm_xfer(&xfer);
+		if (ret)
+			continue;
+
+		ret = ctp_hid_read(ts->mmap->read_flash_checksum_addr, buf, 2);
+		if (ret < 0)
+			continue;
+
+		rd_checksum = (uint16_t)(buf[1] << 8 | buf[0]);
+
+		for (i = 0; i < len; i++)
+			calc += out[i];
+
+		/* 0xFFFF - sum + 1 */
+		calc = 65535 - calc + 1;
+
+		if (rd_checksum == calc)
+			return 0;
+
+		NVT_DBG("flash read checksum mismatch: rd=0x%04X calc=0x%04X", rd_checksum, calc);
+	}
+
+	return -EAGAIN;
+}
+
+static int32_t
+nvt_read_flash_pid_gcm(void)
+{
+	uint8_t pid_raw[4] = {0};
+	char pid_str[5] = {0};
+	gchar *endptr = NULL;
+	guint64 pid64 = 0;
+	int32_t ret = 0;
+
+	if (ts->fmap == NULL || ts->fmap->flash_pid_addr == 0)
+		return -EINVAL;
+
+	ret = switch_gcm(1);
+	if (ret)
+		return ret;
+
+	ret = resume_pd_gcm();
+	if (ret)
+		return ret;
+
+	ret = read_flash_mid_did_gcm();
+	if (ret)
+		return ret;
+
+	ret = nvt_set_read_flash_method();
+	if (ret)
+		return ret;
+
+	ret = nvt_read_flash_data_gcm(ts->fmap->flash_pid_addr, 4, pid_raw);
+	if (ret)
+		return ret;
+
+	/* same byte order as your userland tool: [2][3][0][1] */
+	pid_str[0] = (char)pid_raw[2];
+	pid_str[1] = (char)pid_raw[3];
+	pid_str[2] = (char)pid_raw[0];
+	pid_str[3] = (char)pid_raw[1];
+	pid_str[4] = '\0';
+
+	pid64 = g_ascii_strtoull(pid_str, &endptr, 16);
+	if (endptr == pid_str || *endptr != '\0' || pid64 > 0xFFFF) {
+		NVT_ERR("invalid PID read from flash: '%s' (%02X %02X %02X %02X)",
+			pid_str,
+			pid_raw[0],
+			pid_raw[1],
+			pid_raw[2],
+			pid_raw[3]);
+		return -EINVAL;
+	}
+
+	ts->flash_pid = (uint16_t)pid64;
+	if (ts->flash_pid == 0x0000 || ts->flash_pid == 0xFFFF) {
+		NVT_ERR("pid in flash should not be 0x0000 or 0xFFFF");
+		return -EINVAL;
+	}
+
+	NVT_LOG("flash_pid = 0x%04X", ts->flash_pid);
+	return 0;
+}
+
+static gboolean
+fu_nvt_ts_device_setup(FuDevice *device, GError **error)
+{
+	FuDeviceClass *parent_class;
+	g_autofree gchar *version = NULL;
+	g_autofree gchar *iid = NULL;
+	int32_t ret = 0;
+	uint8_t debug_buf[6] = {0};
+
+	NVT_LOG("device setup");
+
+	if (fu_device_get_vendor(device) == NULL)
+		fu_device_set_vendor(device, "Novatek");
+
+	if (fu_device_get_name(device) == NULL)
+		fu_device_set_name(device, "Novatek Touchscreen");
+
+	if (!fu_device_open(device, error))
+		return FALSE;
+
+	nvt_dev = device;
+
+	/* todo: add mmap mapping if support more IC later on */
+	ts->mmap = &nt36536_cascade_memory_map;
+	ts->fmap = &nt36536_flash_map;
+
+	ctp_hid_read(0x1fb104, debug_buf, 6);
+	NVT_LOG("IC chip id: %02X %02X %02X %02X %02X %02X",
+		debug_buf[0],
+		debug_buf[1],
+		debug_buf[2],
+		debug_buf[3],
+		debug_buf[4],
+		debug_buf[5]);
+
+	if (!(nvt_check_fw_reset_state(RESET_STATE_NORMAL_RUN) == 0 && nvt_get_fw_ver() == 0)) {
+		NVT_LOG("FW is not ready");
+		ts->fw_ver = 0;
+	}
+
+	fu_device_add_protocol(device, "tw.com.novatek.ts");
+	fu_device_set_summary(device, "Novatek touchscreen controller");
+	fu_device_set_version_format(device, FWUPD_VERSION_FORMAT_NUMBER);
+
+	version = g_strdup_printf("%u", ts->fw_ver);
+	fu_device_set_version(device, version);
+
+	nvt_bootloader_reset();
+	nvt_sw_reset_and_idle();
+	nvt_stop_crc_reboot();
+
+	/* get pid in flash to build GUID */
+	ret = nvt_read_flash_pid_gcm();
+	if (ret) {
+		NVT_SET_ERR(FWUPD_ERROR_READ, "failed to read flash PID (ret=%d)", ret);
+		ret = fu_device_close(device, NULL);
+		return FALSE;
+	}
+
+	nvt_bootloader_reset();
+
+	fu_device_build_vendor_id_u16(device, "HIDRAW", NVT_VID_NUM);
+
+	/* build instance id for GUID */
+	iid = g_strdup_printf("NVT_TS\\VID_0603\\PJID_%04X", ts->flash_pid);
+
+	/* turn instance IDs into GUIDs */
+	fu_device_add_instance_id(device, iid);
+
+	fu_device_add_flag(device, FWUPD_DEVICE_FLAG_UPDATABLE);
+	/* fu_device_add_flag(device, FWUPD_DEVICE_FLAG_UNSIGNED_PAYLOAD); */
+
+	if (!fu_device_close(device, NULL))
+		return FALSE;
+
+	parent_class = FU_DEVICE_CLASS(fu_nvt_ts_device_parent_class);
+	if (parent_class->setup != NULL)
+		return parent_class->setup(device, error);
+
+	return TRUE;
+}
+
+static void
+fu_nvt_ts_device_init(FuNvtTsDevice *self)
+{
+	NVT_LOG("device init");
+}
+
+static gboolean
+fu_nvt_ts_device_write_firmware(FuDevice *device,
+				FuFirmware *firmware,
+				FuProgress *progress,
+				FwupdInstallFlags flags,
+				GError **error)
+{
+	g_autoptr(GBytes) blob = NULL;
+	const guint8 *data = NULL;
+	gsize size = 0;
+	int32_t ret;
+	uint8_t retry_left = 3;
+
+	NVT_LOG("device write firmware");
+
+	blob = fu_firmware_get_bytes(firmware, error);
+	if (blob == NULL)
+		return FALSE;
+
+	data = g_bytes_get_data(blob, &size);
+
+#if NVT_DEBUG_DRY_RUN
+	NVT_LOG("NVT_DEBUG_DRY_RUN=1: skip real update");
+	ret = get_binary_and_flash_start_addr_from_blob(data, size);
+	if (ret) {
+		NVT_SET_ERR(FWUPD_ERROR_INVALID_FILE, "failed to parse fw blob (ret=%d)", ret);
+		return FALSE;
+	}
+	NVT_LOG("Dry-run info: fw_size=0x%05X, will flash from 0x%X to 0x%X",
+		fwb.bin_size,
+		fwb.flash_start_addr,
+		fwb.bin_size);
+	/* clean up allocated fw buffer */
+	nvt_fw_bin_clear();
+	return TRUE;
+#endif
+
+	if (!fu_device_open(device, error))
+		return FALSE;
+
+	do {
+		ret = update_firmware_reset(data, size);
+		if (!ret) {
+			NVT_LOG("Update Normal FW OK");
+			break;
+		}
+
+		retry_left--;
+		if (retry_left > 0)
+			NVT_LOG("Update failed (ret=%d), retry %u", ret, retry_left);
+	} while (retry_left > 0);
+
+	if (ret) {
+		NVT_SET_ERR(FWUPD_ERROR_WRITE, "Update Normal FW Failed (ret=%d)", ret);
+		ret = fu_device_close(device, NULL);
+		return FALSE;
+	}
+
+	if (!(nvt_check_fw_reset_state(RESET_STATE_NORMAL_RUN) == 0 && nvt_get_fw_ver() == 0)) {
+		NVT_ERR("FW is not ready");
+		ts->fw_ver = 0;
+	}
+
+	fu_device_set_version(device, g_strdup_printf("%u", ts->fw_ver));
+
+	if (!fu_device_close(device, NULL))
+		return FALSE;
+
+	return TRUE;
+}
+
+static void
+fu_nvt_ts_device_class_init(FuNvtTsDeviceClass *klass)
+{
+	FuDeviceClass *device_class;
+
+	device_class = FU_DEVICE_CLASS(klass);
+	device_class->probe = fu_nvt_ts_device_probe;
+	device_class->setup = fu_nvt_ts_device_setup;
+	device_class->write_firmware = fu_nvt_ts_device_write_firmware;
+}
diff --git a/plugins/nvt-ts/fu-nvt-ts-plugin.h b/plugins/nvt-ts/fu-nvt-ts-plugin.h
new file mode 100644
index 000000000..a7b4595a5
--- /dev/null
+++ b/plugins/nvt-ts/fu-nvt-ts-plugin.h
@@ -0,0 +1,367 @@
+/* SPDX-License-Identifier: LGPL-2.1-or-later */
+#pragma once
+
+#include <fwupdplugin.h>
+
+#include <fcntl.h>
+#include <stdint.h>
+#include <unistd.h>
+
+/* plugin type */
+#define FU_TYPE_NVT_TS_PLUGIN (fu_nvt_ts_plugin_get_type())
+G_DECLARE_FINAL_TYPE(FuNvtTsPlugin, fu_nvt_ts_plugin, FU, NVT_TS_PLUGIN, FuPlugin)
+
+/* device type (hidraw-based), declared in the same header */
+#define FU_TYPE_NVT_TS_DEVICE (fu_nvt_ts_device_get_type())
+G_DECLARE_FINAL_TYPE(FuNvtTsDevice, fu_nvt_ts_device, FU, NVT_TS_DEVICE, FuHidrawDevice)
+
+#define NVT_TS_REPORT_ID 0x0B
+
+#define NVT_DBG(fmt, ...)                                                                          \
+	G_STMT_START                                                                               \
+	{                                                                                          \
+		g_debug("[NVT_TS][Debug] {%s} %s +%d : " fmt,                                      \
+			__func__,                                                                  \
+			__FILE__,                                                                  \
+			__LINE__,                                                                  \
+			##__VA_ARGS__);                                                            \
+	}                                                                                          \
+	G_STMT_END
+
+#define NVT_LOG(fmt, ...)                                                                          \
+	G_STMT_START                                                                               \
+	{                                                                                          \
+		g_info("[NVT_TS][Info ] {%s} %s +%d : " fmt,                                       \
+		       __func__,                                                                   \
+		       __FILE__,                                                                   \
+		       __LINE__,                                                                   \
+		       ##__VA_ARGS__);                                                             \
+	}                                                                                          \
+	G_STMT_END
+
+#define NVT_ERR(fmt, ...)                                                                          \
+	G_STMT_START                                                                               \
+	{                                                                                          \
+		g_warning("[NVT_TS][Error] {%s} %s +%d : " fmt,                                    \
+			  __func__,                                                                \
+			  __FILE__,                                                                \
+			  __LINE__,                                                                \
+			  ##__VA_ARGS__);                                                          \
+	}                                                                                          \
+	G_STMT_END
+
+#define NVT_SET_ERR(fwupd_err, fmt, ...)                                                           \
+	G_STMT_START                                                                               \
+	{                                                                                          \
+		NVT_ERR(fmt, ##__VA_ARGS__);                                                       \
+		g_set_error(error, FWUPD_ERROR, fwupd_err, fmt, ##__VA_ARGS__);                    \
+	}                                                                                          \
+	G_STMT_END
+
+/* shared hex body */
+#define NVT_HEX_IMPL(prefix, glib_fn, data, len)                                                   \
+	G_STMT_START                                                                               \
+	{                                                                                          \
+		GString *_s = g_string_new(NULL);                                                  \
+		for (gsize _i = 0; _i < (gsize)(len); _i++) {                                      \
+			if ((_i % 16) == 0)                                                        \
+				g_string_append(_s, prefix);                                       \
+			g_string_append_printf(_s, "%02X", ((const guint8 *)(data))[_i]);          \
+			if (((_i + 1) % 16) == 0)                                                  \
+				g_string_append_c(_s, '\n');                                       \
+			else                                                                       \
+				g_string_append_c(_s, ' ');                                        \
+		}                                                                                  \
+		if ((len) % 16 != 0)                                                               \
+			g_string_append_c(_s, '\n');                                               \
+		glib_fn("%s", _s->str);                                                            \
+		g_string_free(_s, TRUE);                                                           \
+	}                                                                                          \
+	G_STMT_END
+
+#define NVT_DBG_HEX(data, len) NVT_HEX_IMPL("[NVT_TS][Debug] ", g_debug, data, len)
+
+#define NVT_LOG_HEX(data, len) NVT_HEX_IMPL("[NVT_TS][Info ] ", g_info, data, len)
+
+#define NVT_ERR_HEX(data, len) NVT_HEX_IMPL("[NVT_TS][Error] ", g_warning, data, len)
+
+#ifndef msleep
+#define msleep(ms) g_usleep((gulong)(ms)*1000)
+#endif
+
+#define NVT_VID_NUM		 0x0603
+#define NT36536_PDID		 0xF203u
+#define FLASH_PAGE_SIZE		 256
+#define NVT_TRANSFER_LEN	 256
+#define SIZE_4KB		 (1024 * 4)
+#define SIZE_64KB		 (1024 * 64)
+#define SIZE_320KB		 (1024 * 320)
+#define BLOCK_64KB_NUM		 4
+#define BYTE_PER_POINT		 2
+#define FLASH_SECTOR_SIZE	 SIZE_4KB
+#define MAX_BIN_SIZE		 SIZE_320KB
+#define FLASH_DID_ALL		 0xFFFF
+#define HID_FW_BIN_END_NAME_FULL "NVT"
+#define BIN_END_FLAG_LEN_FULL	 3
+#define BIN_END_FLAG_LEN_MAX	 4
+
+typedef struct nvt_ts_reg {
+	uint32_t addr;
+	uint8_t mask;
+} nvt_ts_reg_t;
+
+struct nvt_ts_mem_map {
+	uint32_t chip_ver_trim_addr;
+	uint32_t swrst_sif_addr;
+	uint32_t event_buf_cmd_addr;
+	uint32_t event_buf_hs_sub_cmd_addr;
+	uint32_t event_buf_reset_state_addr;
+	uint32_t event_map_fwinfo_addr;
+	uint32_t read_flash_checksum_addr;
+	uint32_t rw_flash_data_addr;
+	uint32_t enb_casc_addr;
+	uint32_t hid_i2c_eng_addr;
+	uint32_t gcm_code_addr;
+	uint32_t gcm_flag_addr;
+	uint32_t flash_cmd_addr;
+	uint32_t flash_cmd_issue_addr;
+	uint32_t flash_cksum_status_addr;
+	uint32_t bld_spe_pups_addr;
+	nvt_ts_reg_t pp4io_en_reg;
+	nvt_ts_reg_t bld_rd_addr_sel_reg;
+	nvt_ts_reg_t bld_rd_io_sel_reg;
+	uint32_t q_wr_cmd_addr;
+};
+
+struct nvt_ts_flash_map {
+	uint32_t flash_normal_fw_start_addr;
+	uint32_t flash_pid_addr;
+	uint32_t flash_fw_size;
+};
+
+static const struct nvt_ts_mem_map nt36536_cascade_memory_map = {
+    .read_flash_checksum_addr = 0x100000,
+    .rw_flash_data_addr = 0x100002,
+    .event_buf_cmd_addr = 0x130950,
+    .event_buf_hs_sub_cmd_addr = 0x130951,
+    .event_buf_reset_state_addr = 0x130960,
+    .event_map_fwinfo_addr = 0x130978,
+    .chip_ver_trim_addr = 0x1FB104,
+    .enb_casc_addr = 0x1FB12C,
+    .swrst_sif_addr = 0x1FB43E,
+    .hid_i2c_eng_addr = 0x1FB468,
+    .bld_spe_pups_addr = 0x1FB535,
+    .gcm_code_addr = 0x1FB540,
+    .flash_cmd_addr = 0x1FB543,
+    .flash_cmd_issue_addr = 0x1FB54E,
+    .flash_cksum_status_addr = 0x1FB54F,
+    .gcm_flag_addr = 0x1FB553,
+};
+
+static const struct nvt_ts_flash_map nt36536_flash_map = {
+    .flash_normal_fw_start_addr = 0x2000,
+    .flash_pid_addr = 0x3F004,
+    .flash_fw_size = 0x3C000,
+};
+
+typedef struct gcm_transfer {
+	uint8_t flash_cmd;
+	uint32_t flash_addr;
+	uint16_t flash_checksum;
+	uint8_t flash_addr_len;
+	uint8_t pem_byte_len;
+	uint8_t dummy_byte_len;
+	uint8_t *tx_buf;
+	uint16_t tx_len;
+	uint8_t *rx_buf;
+	uint16_t rx_len;
+} gcm_xfer_t;
+
+enum { RESET_STATE_INIT = 0xA0,
+       RESET_STATE_REK_BASELINE,
+       RESET_STATE_REK_FINISH,
+       RESET_STATE_NORMAL_RUN,
+       RESET_STATE_MAX = 0xAF };
+
+struct fw_bin {
+	uint8_t *bin_data;
+	uint32_t bin_size;
+	uint32_t flash_start_addr;
+};
+
+/* flash manufacturer idenfication */
+typedef enum {
+	FLASH_MFR_UNKNOWN = 0x00,
+	FLASH_MFR_ESMT = 0x1C,
+	FLASH_MFR_PUYA = 0x85,	     /* puya */
+	FLASH_MFR_FM = 0xA1,	     /* fm */
+	FLASH_MFR_MACRONIX = 0xC2,   /* macronix */
+	FLASH_MFR_GIGADEVICE = 0xC8, /* gigadevice */
+	FLASH_MFR_WINBOND = 0xEF,    /* winbond */
+	FLASH_MFR_MAX = 0xFF
+} flash_mfr_t;
+
+/* find "QE" or "status register" */
+typedef enum {
+	QEB_POS_UNKNOWN = 0,
+	QEB_POS_SR_1B, /* qe bit in SR 1st byte */
+	QEB_POS_OTHER, /* qe bit not in SR 1st byte */
+	QEB_POS_MAX
+} qeb_pos_t;
+
+/* search "write status register" or "wrsr" */
+typedef enum {
+	FLASH_WRSR_METHOD_UNKNOWN = 0,
+	WRSR_01H1BYTE, /* 01H (S7-S0) */
+	WRSR_01H2BYTE, /* 01H (S7-S0) (S15-S8) */
+	FLASH_WRSR_METHOD_MAX
+} flash_wrsr_method_t;
+
+typedef struct flash_qeb_info {
+	qeb_pos_t qeb_pos; /* qe bit position type, ex. in SR 1st/2nd byte, etc */
+	uint8_t qeb_order; /* in which bit of that byte, start from bit 0 */
+} flash_qeb_info_t;
+
+/* find "03h" or "read data bytes" */
+typedef enum {
+	FLASH_READ_METHOD_UNKNOWN = 0,
+	SISO_0x03,
+	SISO_0x0B,
+	SIQO_0x6B,
+	QIQO_0xEB,
+	FLASH_READ_METHOD_MAX
+} flash_read_method_t;
+
+/* find "page program" */
+typedef enum {
+	FLASH_PROG_METHOD_UNKNOWN = 0,
+	SPP_0x02, /* singalPageProgram_0x02 */
+	QPP_0x32, /* quadPageProgram_0x32 */
+	QPP_0x38, /* quadPageProgram_0x38 */
+	FLASH_PROG_METHOD_MAX
+} flash_prog_method_t;
+
+typedef enum {
+	FLASH_LOCK_METHOD_UNKNOWN,
+	FLASH_LOCK_METHOD_SW_BP_ALL,
+	FLASH_LOCK_METHOD_MAX,
+} flash_lock_method_t;
+
+typedef struct flash_info {
+	flash_mfr_t mid; /* manufacturer identification */
+	uint16_t did;	 /* 2 bytes device identification read by 0x9F RDID */
+			 /* command manufacturer ID, memory type, memory density */
+	flash_qeb_info_t qeb_info;
+	flash_read_method_t rd_method;	 /* flash read method */
+	flash_prog_method_t prog_method; /* flash program method */
+	flash_wrsr_method_t wrsr_method; /* write status register method */
+	/* find "rdsr" or "read status register" */
+	uint8_t rdsr1_cmd;		 /* cmd for read status register-2 (S15-S8) */
+	flash_lock_method_t lock_method; /* block protect position */
+	uint8_t sr_bp_bits_all;		 /* bp all protect bits setting in SR for */
+					 /* FLASH_LOCK_METHOD_SW_BP_ALL */
+} flash_info_t;
+
+static const flash_info_t flash_info_table[] = {
+    /* please put flash info items which will use quad mode and is verified */
+    /* before those with "did = FLASH_DID_ALL"! */
+    {.mid = FLASH_MFR_GIGADEVICE,
+     .did = 0x4013,
+     .qeb_info = {.qeb_pos = QEB_POS_OTHER, .qeb_order = 0xFF},
+     .rd_method = SISO_0x03,
+     .prog_method = SPP_0x02,
+     .wrsr_method = WRSR_01H2BYTE,
+     .rdsr1_cmd = 0x35},
+    {.mid = FLASH_MFR_GIGADEVICE,
+     .did = 0x6012,
+     .qeb_info = {.qeb_pos = QEB_POS_OTHER, .qeb_order = 0xFF},
+     .rd_method = SISO_0x03,
+     .prog_method = SPP_0x02,
+     .wrsr_method = WRSR_01H1BYTE,
+     .rdsr1_cmd = 0xFF},
+    {.mid = FLASH_MFR_GIGADEVICE,
+     .did = 0x6016,
+     .qeb_info = {.qeb_pos = QEB_POS_OTHER, .qeb_order = 0xFF},
+     .rd_method = SISO_0x03,
+     .prog_method = SPP_0x02,
+     .wrsr_method = WRSR_01H2BYTE,
+     .rdsr1_cmd = 0x35},
+    {.mid = FLASH_MFR_PUYA,
+     .did = 0x4412,
+     .qeb_info = {.qeb_pos = QEB_POS_OTHER, .qeb_order = 0xFF},
+     .rd_method = SISO_0x03,
+     .prog_method = SPP_0x02,
+     .wrsr_method = WRSR_01H1BYTE,
+     .rdsr1_cmd = 0xFF},
+    {.mid = FLASH_MFR_PUYA,
+     .did = 0x6013,
+     .qeb_info = {.qeb_pos = QEB_POS_OTHER, .qeb_order = 0xFF},
+     .rd_method = SISO_0x03,
+     .prog_method = SPP_0x02,
+     .wrsr_method = WRSR_01H2BYTE,
+     .rdsr1_cmd = 0x35},
+    {.mid = FLASH_MFR_PUYA,
+     .did = 0x6015,
+     .qeb_info = {.qeb_pos = QEB_POS_OTHER, .qeb_order = 0xFF},
+     .rd_method = SISO_0x03,
+     .prog_method = SPP_0x02,
+     .wrsr_method = WRSR_01H2BYTE,
+     .rdsr1_cmd = 0x35},
+    {.mid = FLASH_MFR_WINBOND,
+     .did = 0x3012,
+     .qeb_info = {.qeb_pos = QEB_POS_OTHER, .qeb_order = 0xFF},
+     .rd_method = SISO_0x03,
+     .prog_method = SPP_0x02,
+     .wrsr_method = WRSR_01H1BYTE,
+     .rdsr1_cmd = 0xFF},
+    {.mid = FLASH_MFR_WINBOND,
+     .did = 0x6016,
+     .qeb_info = {.qeb_pos = QEB_POS_OTHER, .qeb_order = 0xFF},
+     .rd_method = SISO_0x03,
+     .prog_method = SPP_0x02,
+     .wrsr_method = WRSR_01H1BYTE,
+     .rdsr1_cmd = 0x35},
+    {.mid = FLASH_MFR_MACRONIX,
+     .did = 0x2813,
+     .qeb_info = {.qeb_pos = QEB_POS_SR_1B, .qeb_order = 6},
+     .rd_method = SISO_0x03,
+     .prog_method = SPP_0x02,
+     .wrsr_method = WRSR_01H1BYTE,
+     .rdsr1_cmd = 0xFF},
+    {.mid = FLASH_MFR_FM,
+     .did = 0x2813,
+     .qeb_info = {.qeb_pos = QEB_POS_OTHER, .qeb_order = 1},
+     .rd_method = SISO_0x03,
+     .prog_method = SPP_0x02,
+     .wrsr_method = WRSR_01H2BYTE,
+     .rdsr1_cmd = 0x35},
+    {.mid = FLASH_MFR_WINBOND,
+     .did = 0x6012,
+     .qeb_info = {.qeb_pos = QEB_POS_OTHER, .qeb_order = 0xFF},
+     .rd_method = SISO_0x03,
+     .prog_method = SPP_0x02,
+     .wrsr_method = WRSR_01H1BYTE,
+     .rdsr1_cmd = 0x35},
+    /* please note that the following flash info item should be keep at the last one! Do not move
+       it! */
+    {.mid = FLASH_MFR_UNKNOWN,
+     .did = FLASH_DID_ALL,
+     .qeb_info = {.qeb_pos = QEB_POS_UNKNOWN, .qeb_order = 0xFF},
+     .rd_method = SISO_0x03,
+     .prog_method = SPP_0x02,
+     .wrsr_method = FLASH_WRSR_METHOD_UNKNOWN,
+     .rdsr1_cmd = 0xFF}};
+
+struct nvt_ts_data {
+	const struct nvt_ts_mem_map *mmap;
+	const struct nvt_ts_flash_map *fmap;
+	uint8_t fw_ver;
+	uint8_t flash_mid;
+	uint16_t flash_did;
+	uint16_t flash_pid;
+	const flash_info_t *match_finfo;
+	uint8_t flash_prog_data_cmd;
+	uint8_t flash_read_data_cmd;
+	uint8_t flash_read_pem_byte_len;
+	uint8_t flash_read_dummy_byte_len;
+};
diff --git a/plugins/nvt-ts/meson.build b/plugins/nvt-ts/meson.build
new file mode 100644
index 000000000..d07a7bce7
--- /dev/null
+++ b/plugins/nvt-ts/meson.build
@@ -0,0 +1,15 @@
+host_machine.system() in ['linux', 'android'] or subdir_done()
+
+cargs = ['-DG_LOG_DOMAIN="FuPluginNvtTs"']
+
+plugins += { meson.current_source_dir().split('/')[-1] : true }
+
+plugin_builtins += static_library(
+  'fu_plugin_nvt_ts',
+  sources: ['fu-nvt-ts-plugin.c'],
+  include_directories: plugin_incdirs,
+  link_with: plugin_libs,
+  c_args: cargs,
+  dependencies: plugin_deps,
+)
+
diff --git a/plugins/nvt-ts/nvt-ts.quirk b/plugins/nvt-ts/nvt-ts.quirk
new file mode 100644
index 000000000..aed7f0554
--- /dev/null
+++ b/plugins/nvt-ts/nvt-ts.quirk
@@ -0,0 +1,3 @@
+[HIDRAW\VEN_0603]
+Plugin = nvt_ts
+
-- 
2.43.0

